def generate_permutations(list):
    
    # Initialize list for SJT compatible tuple: (sorted int, direction (-1 for left, 1 for right))
    sjt_list = []

    # Initialize list of all permutations generated by this algorithm
    permutations = []

    # Add sorted ints pointing left to sjt_list
    for num in sorted(list):
        sjt_list.append((num, -1))

    lmi_index = None

    # Loop until no more mobile integers
    while True:
        
        # Add current permutation to list to return
        permutation = []
        for num, dir in sjt_list:
            permutation.append(num)
        permutations.append(permutation)

        # Reset largest mobile integer
        lmi_index = None

        # Loop through SJT list to find largest mobile integer
        for i in range(len(sjt_list)):
            num, dir = sjt_list[i]

            # Check if index is mobile (greater than index it is pointing to)
            if (0 <= i + dir < len(sjt_list)) and num > sjt_list[i + dir][0]:
                # Check if index is greater than current largest mobile integer
                if lmi_index is None or num > sjt_list[lmi_index][0]:
                    lmi_index = i

        # If no lmi was found, return
        if lmi_index is None:
            break

        # Swap largest mobile integer with neighbor it points to
        lmi = sjt_list[lmi_index]
        temp = sjt_list[lmi_index + lmi[1]]
        sjt_list[lmi_index + lmi[1]] = sjt_list[lmi_index]
        sjt_list[lmi_index] = temp

        #Loop to swap direction of all integers greater than mobile integer
        for i in range(len(sjt_list)):
            num, dir = sjt_list[i]
            if num > lmi[0]:
                sjt_list[i] = (num, dir * -1)

    return permutations